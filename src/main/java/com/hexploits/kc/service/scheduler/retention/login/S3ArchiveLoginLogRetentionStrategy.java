package com.hexploits.kc.service.scheduler.retention.login;

import com.hexploits.kc.dto.response.LoginLogResponse;
import com.hexploits.kc.repository.KcLoginLogRepository;
import com.hexploits.kc.service.aws.S3Adapter;
import com.opencsv.CSVWriter;
import io.micronaut.context.annotation.Replaces;
import io.micronaut.context.annotation.Requires;
import jakarta.inject.Singleton;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.time.Instant;
import java.time.OffsetDateTime;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Singleton
@Replaces(ILoginLogRetentionStrategy.class)
@Requires(property = "kc.logs.login.strategy", value = "s3")
public class S3ArchiveLoginLogRetentionStrategy implements ILoginLogRetentionStrategy {

  private final Logger log = LoggerFactory.getLogger(S3ArchiveLoginLogRetentionStrategy.class);
  private final KcLoginLogRepository kcLoginLogRepository;
  private final S3Adapter s3Adapter;

  public S3ArchiveLoginLogRetentionStrategy(KcLoginLogRepository kcLoginLogRepository,
    S3Adapter s3Adapter) {
    this.kcLoginLogRepository = kcLoginLogRepository;
    this.s3Adapter = s3Adapter;
  }

  @Override
  public void process(Optional<Integer> days) {
    Integer noOfDays = days.orElse(365);
    OffsetDateTime fetchBeforeDate = OffsetDateTime.now().minus(noOfDays, ChronoUnit.DAYS);
    log.info("Archiving all login logs before {} to S3.", fetchBeforeDate);

    File file = writeCsv(fetchBeforeDate);
    String path = "/retention/logs/logins/" + Instant.now().toString();
    s3Adapter.uploadFile(file, path, ".csv");
    kcLoginLogRepository.deleteLogsBefore(fetchBeforeDate);
  }

  private File writeCsv(OffsetDateTime fetchBeforeDate) {
    List<LoginLogResponse> logs = kcLoginLogRepository.fetchLogsBefore(fetchBeforeDate);

    File file = null;
    try {
      file = File.createTempFile("logins-", null);
    } catch (IOException e) {
      log.error("Failed to create temporary file: {}", e.getLocalizedMessage());
      throw new IllegalStateException("Failed to create temporary file: " + e.getLocalizedMessage());
    }

    try {
      FileWriter outputFile = new FileWriter(file);
      CSVWriter writer = new CSVWriter(outputFile);

      String[] header = {
        "Login Log Uid",
        "Username",
        "External Reference",
        "Login Result",
        "Created At"
      };
      writer.writeNext(header);

      logs.forEach(l -> {
        List<String> row = new ArrayList<>();
        row.add(l.getLogUid().toString());
        row.add(l.getUsername());
        row.add(l.getExternalReference());
        row.add(l.getLoginResult().toString());
        row.add(l.getCreatedAt().toString());

        String[] finalRow = row.toArray(String[]::new);
        writer.writeNext(finalRow);
      });

      // closing writer connection
      writer.close();
    } catch (IOException e) {
      log.error("Failed to write event log CSV: {}", e.getLocalizedMessage());
      throw new IllegalStateException("Failed to write event log CSV: " + e.getLocalizedMessage());
    }

    return file;
  }
}

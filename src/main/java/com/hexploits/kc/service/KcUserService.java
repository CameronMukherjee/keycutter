package com.hexploits.kc.service;

import com.hexploits.kc.dto.internal.EventType;
import com.hexploits.kc.dto.request.CreateUserRequest;
import com.hexploits.kc.dto.request.UpdatePasswordRequest;
import com.hexploits.kc.dto.request.UpdateUserRequest;
import com.hexploits.kc.dto.response.FetchUserResponse;
import com.hexploits.kc.dto.response.UserResponse;
import com.hexploits.kc.model.KcUser;
import com.hexploits.kc.repository.KcUserRepository;
import com.hexploits.kc.repository.KcUserRoleRepository;
import com.hexploits.kc.service.email.IEmailService;
import com.hexploits.kc.service.event.KcCommandEvent;
import com.hexploits.kc.service.event.KcCommandPublisher;
import io.micronaut.transaction.annotation.ReadOnly;
import jakarta.inject.Singleton;
import java.security.SecureRandom;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;
import javax.transaction.Transactional;
import org.apache.commons.lang3.RandomStringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Singleton
public class KcUserService {

  private final Logger log = LoggerFactory.getLogger(KcUserService.class);
  private final IEmailService emailService;
  private final KcPasswordEncoder passwordEncoder;
  private final KcCommandPublisher kcCommandPublisher;
  private final KcUserRepository kcUserRepository;
  private final KcUserRoleRepository kcUserRoleRepository;

  public KcUserService(
    IEmailService emailService,
    KcPasswordEncoder passwordEncoder,
    KcCommandPublisher kcCommandPublisher,
    KcUserRepository kcUserRepository,
    KcUserRoleRepository kcUserRoleRepository) {
    this.emailService = emailService;
    this.passwordEncoder = passwordEncoder;
    this.kcCommandPublisher = kcCommandPublisher;
    this.kcUserRepository = kcUserRepository;
    this.kcUserRoleRepository = kcUserRoleRepository;
  }

  @Transactional
  public KcUser createUser(CreateUserRequest request) {
    KcUser user = kcUserRepository.save(mapCreate(request));
    addRoles(user.getUsername(), request.getRoles());
    emailService.sendWelcome(user);

    kcCommandPublisher.publishEvent(
      new KcCommandEvent(
        KcUserService.class,
        user,
        EventType.USER_CREATED,
        Optional.empty()
      )
    );

    return user;
  }

  @Transactional
  public void updateUser(UpdateUserRequest request) {
    String hash = passwordEncoder.encode(request.getPassword());
    kcUserRepository.updateUser(request.getUid(), request.getExternalReference(), request.getUsername(), hash);
    KcUser user = fetchUser(request.getUsername());

    kcCommandPublisher.publishEvent(
      new KcCommandEvent(
        KcUserService.class,
        user,
        EventType.USER_UPDATED,
        Optional.empty()
      )
    );

    removeAllRoles(user);
    addRoles(user.getUsername(), request.getRoles());
  }

  public FetchUserResponse fetchUserResponseByUsername(String username) {
    KcUser user = kcUserRepository
      .findByUsername(username)
      .orElseThrow(() -> new IllegalArgumentException("Failed to find user with that username"));

    List<String> roles = fetchRoles(user.getUsername());

    return mapFetch(user, roles);
  }

  public FetchUserResponse fetchUserResponseByExternalReference(String externalReference) {
    KcUser user = kcUserRepository
      .findByExternalReferenceEqual(externalReference)
      .orElseThrow(() -> new IllegalArgumentException("Failed to find user with that username"));

    List<String> roles = fetchRoles(user.getUsername());

    return mapFetch(user, roles);
  }

  @ReadOnly
  public List<FetchUserResponse> fetchUsers(Optional<Integer> limit) {
    return kcUserRepository.fetchUsers(limit.orElse(10))
      .stream()
      .map(user -> {
        List<String> roles = fetchRoles(user.getUsername());
        return mapFetch(user, roles);
      }).collect(Collectors.toList());
  }

  @ReadOnly
  public KcUser fetchUser(String username) {
    return kcUserRepository
      .findByUsername(username)
      .orElseThrow(() -> new IllegalArgumentException("Failed to find user with that username"));
  }

  @Transactional
  public void disableUserAccount(String username) {
    KcUser user = fetchUser(username);
    kcCommandPublisher.publishEvent(
      new KcCommandEvent(
        KcUserService.class,
        user,
        EventType.USER_DISABLED,
        Optional.empty()
      )
    );
    kcUserRepository.disableAccount(username);
  }

  @Transactional
  public void enableUserAccount(String username) {
    KcUser user = fetchUser(username);
    kcCommandPublisher.publishEvent(
      new KcCommandEvent(
        KcUserService.class,
        user,
        EventType.USER_ENABLED,
        Optional.empty()
      )
    );
    kcUserRepository.enableAccount(username);
  }

  @Transactional
  public void updatePassword(UpdatePasswordRequest updatePasswordRequest) {
    KcUser user = fetchUser(updatePasswordRequest.getUsername());
    if (passwordEncoder.matches(updatePasswordRequest.getOldPassword(), user.getPassword())) {
      String newHash = passwordEncoder.encode(updatePasswordRequest.getNewPassword());

      kcUserRepository.updatePassword(updatePasswordRequest.getUsername(), newHash);
      kcCommandPublisher.publishEvent(
        new KcCommandEvent(
          KcUserService.class,
          user,
          EventType.USER_PASSWORD_CHANGE,
          Optional.empty()
        )
      );
    } else {
      throw new IllegalArgumentException("Password is incorrect.");
    }
  }

  /**
   * Sets a new temporary password and returns it.
   *
   * @param username
   * @return
   */
  @Transactional
  public String resetPassword(String username) {
    char[] possibleCharacters = ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
      + "!@#$()-_=+[{]}<>?").toCharArray();

    String newPassword = RandomStringUtils.random(
      16,
      0,
      possibleCharacters.length - 1,
      false,
      false,
      possibleCharacters,
      new SecureRandom()
    );

    String hash = passwordEncoder.encode(newPassword);

    KcUser user = fetchUser(username);
    kcUserRepository.updatePassword(username, hash);
    emailService.sendPasswordReset(user, newPassword);
    kcCommandPublisher.publishEvent(
      new KcCommandEvent(
        KcUserService.class,
        user,
        EventType.USER_RESET_PASSWORD,
        Optional.of("Temporary password is: " + newPassword)
      )
    );

    return newPassword;
  }

  @Transactional
  public void deleteUser(String username) {
    KcUser user = fetchUser(username);
    kcCommandPublisher.publishEvent(
      new KcCommandEvent(
        KcUserService.class,
        user,
        EventType.USER_DELETED,
        Optional.empty()
      )
    );
    kcUserRepository.deleteUser(username);
  }


  @ReadOnly
  public List<String> fetchRoles(String username) {
    return kcUserRoleRepository.fetchRoles(username);
  }

  @ReadOnly
  public List<UserResponse> fetchUsersByRole(String role) {
    return kcUserRoleRepository.fetchUsersByRole(role);
  }

  // Roles have been added her to prevent circular dependency between the UserRole service and UserService.
  @Transactional
  public void addRoles(String username, List<String> roles) {
    if (roles == null) {
      log.error("Attempting to add no roles to user: {}", username);

      throw new IllegalArgumentException("No roles provided");
    }

    List<String> currentRoles = fetchRoles(username);
    roles.forEach(role -> {
      if (!currentRoles.contains(role)) {
        kcUserRoleRepository.saveRole(UUID.randomUUID(), username, role);
        KcUser user = fetchUser(username);
        kcCommandPublisher.publishEvent(
          new KcCommandEvent(
            KcUserService.class,
            user,
            EventType.ROLE_APPENDED,
            Optional.of(role)
          )
        );
      }
    });
  }

  @Transactional
  public void removeRole(String username, String role) {
    KcUser user = fetchUser(username);
    kcCommandPublisher.publishEvent(
      new KcCommandEvent(
        KcUserService.class,
        user,
        EventType.ROLE_REMOVED,
        Optional.of(role)
      )
    );
    kcUserRoleRepository.removeRole(username, role);
  }

  @Transactional
  public void removeAllRoles(KcUser user) {
    kcCommandPublisher.publishEvent(
      new KcCommandEvent(
        KcUserService.class,
        user,
        EventType.ROLES_REMOVED,
        Optional.empty()
      )
    );

    kcUserRoleRepository.removeAllRoles(user.getUsername());
  }

  public FetchUserResponse mapFetch(KcUser user, List<String> roles) {
    return new FetchUserResponse(
      user.getUid(),
      user.getUsername(),
      user.getExternalReference(),
      user.getIsDisabled(),
      user.getUpdatedAt(),
      user.getCreatedAt(),
      roles
    );
  }

  private KcUser mapCreate(CreateUserRequest request) {
    return new KcUser(
      UUID.randomUUID(),
      request.getExternalReference(),
      request.getUsername(),
      passwordEncoder.encode(request.getPassword()),
      false,
      OffsetDateTime.now(),
      OffsetDateTime.now()
    );
  }
}

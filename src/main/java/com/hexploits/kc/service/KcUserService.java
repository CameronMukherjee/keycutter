package com.hexploits.kc.service;

import com.hexploits.kc.dto.request.CreateUserRequest;
import com.hexploits.kc.dto.request.UpdatePasswordRequest;
import com.hexploits.kc.dto.request.UpdateUserRequest;
import com.hexploits.kc.dto.response.FetchUserResponse;
import com.hexploits.kc.dto.response.UserCreatedResponse;
import com.hexploits.kc.model.KcUser;
import com.hexploits.kc.repository.KcUserRepository;
import io.micronaut.transaction.annotation.ReadOnly;
import jakarta.inject.Singleton;
import java.time.OffsetDateTime;
import java.util.UUID;
import javax.transaction.Transactional;

@Singleton
public class KcUserService {

  private final KcUserRoleService kcUserRoleService;
  private final KcUserRepository kcUserRepository;
  private final KcPasswordEncoder passwordEncoder;

  public KcUserService(KcUserRoleService kcUserRoleService, KcUserRepository kcUserRepository,
    KcPasswordEncoder passwordEncoder) {
    this.kcUserRoleService = kcUserRoleService;
    this.kcUserRepository = kcUserRepository;
    this.passwordEncoder = passwordEncoder;
  }

  @Transactional
  public KcUser createUser(CreateUserRequest request) {

    KcUser user = kcUserRepository.save(mapCreate(request));
    kcUserRoleService.addRoles(request.getUsername(), request.getRoles());
    return user;
  }

  @Transactional
  public KcUser updateUser(UpdateUserRequest request) {
    String hash = passwordEncoder.encode(request.getPassword());
    kcUserRepository.updateUser(request.getUid(), request.getExternalReference(), request.getUsername(), hash);

    kcUserRoleService.removeAllRoles(request.getUsername());
    kcUserRoleService.addRoles(request.getUsername(), request.getRoles());

    return fetchUser(request.getUsername());
  }

  @ReadOnly
  public KcUser fetchUser(String username) {
    return kcUserRepository
      .findByUsername(username)
      .orElseThrow(() -> new IllegalArgumentException("Failed to find user with that username"));
  }

  @Transactional
  public void disableUserAccount(String username) {
    kcUserRepository.disableAccount(username);
  }

  @Transactional
  public void enableUserAccount(String username) {
    kcUserRepository.enableAccount(username);
  }

  @Transactional
  public void updatePassword(UpdatePasswordRequest updatePasswordRequest) {
    KcUser user = fetchUser(updatePasswordRequest.getUsername());
    if (passwordEncoder.matches(updatePasswordRequest.getOldPassword(), user.getPassword())) {
      String newHash = passwordEncoder.encode(updatePasswordRequest.getNewPassword());

      kcUserRepository.updatePassword(updatePasswordRequest.getUsername(), newHash);
    } else {
      throw new IllegalArgumentException("Password is incorrect.");
    }
  }

  @Transactional
  public void deleteUser(String username) {
    kcUserRepository.deleteUser(username);
  }

  public UserCreatedResponse mapCreate(KcUser user) {
    return new UserCreatedResponse(user.getUid());
  }

  public FetchUserResponse mapFetch(KcUser user) {
    return new FetchUserResponse(
      user.getUsername(),
      user.getExternalReference(),
      user.getIsDisabled(),
      user.getUpdatedAt(),
      user.getCreatedAt()
    );
  }

  private KcUser mapCreate(CreateUserRequest request) {
    return new KcUser(
      UUID.randomUUID(),
      request.getExternalReference(),
      request.getUsername(),
      passwordEncoder.encode(request.getPassword()),
      false,
      OffsetDateTime.now(),
      OffsetDateTime.now()
    );
  }
}

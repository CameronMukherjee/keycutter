package com.hexploits.kc.service;

import com.hexploits.kc.dto.request.CreateUserRequest;
import com.hexploits.kc.dto.request.UpdatePasswordRequest;
import com.hexploits.kc.dto.request.UpdateUserRequest;
import com.hexploits.kc.dto.response.FetchUserResponse;
import com.hexploits.kc.model.KcUser;
import com.hexploits.kc.repository.KcUserRepository;
import com.hexploits.kc.service.email.IEmailService;
import io.micronaut.transaction.annotation.ReadOnly;
import jakarta.inject.Singleton;
import java.security.SecureRandom;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.UUID;
import javax.transaction.Transactional;
import org.apache.commons.lang3.RandomStringUtils;

@Singleton
public class KcUserService {

  private final IEmailService emailService;
  private final KcUserRoleService kcUserRoleService;
  private final KcUserRepository kcUserRepository;
  private final KcPasswordEncoder passwordEncoder;

  public KcUserService(IEmailService emailService, KcUserRoleService kcUserRoleService,
    KcUserRepository kcUserRepository, KcPasswordEncoder passwordEncoder) {
    this.emailService = emailService;
    this.kcUserRoleService = kcUserRoleService;
    this.kcUserRepository = kcUserRepository;
    this.passwordEncoder = passwordEncoder;
  }

  @Transactional
  public KcUser createUser(CreateUserRequest request) {

    KcUser user = kcUserRepository.save(mapCreate(request));
    kcUserRoleService.addRoles(request.getUsername(), request.getRoles());
    emailService.sendWelcome(request.getUsername());
    return user;
  }

  @Transactional
  public KcUser updateUser(UpdateUserRequest request) {
    String hash = passwordEncoder.encode(request.getPassword());
    kcUserRepository.updateUser(request.getUid(), request.getExternalReference(), request.getUsername(), hash);

    kcUserRoleService.removeAllRoles(request.getUsername());
    kcUserRoleService.addRoles(request.getUsername(), request.getRoles());

    return fetchUser(request.getUsername());
  }

  public FetchUserResponse fetchUserResponse(String username) {
    KcUser user = kcUserRepository
      .findByUsername(username)
      .orElseThrow(() -> new IllegalArgumentException("Failed to find user with that username"));

    List<String> roles = kcUserRoleService.fetchRoles(username);

    return mapFetch(user, roles);
  }

  @ReadOnly
  public KcUser fetchUser(String username) {
    return kcUserRepository
      .findByUsername(username)
      .orElseThrow(() -> new IllegalArgumentException("Failed to find user with that username"));
  }

  @Transactional
  public void disableUserAccount(String username) {
    kcUserRepository.disableAccount(username);
  }

  @Transactional
  public void enableUserAccount(String username) {
    kcUserRepository.enableAccount(username);
  }

  @Transactional
  public void updatePassword(UpdatePasswordRequest updatePasswordRequest) {
    KcUser user = fetchUser(updatePasswordRequest.getUsername());
    if (passwordEncoder.matches(updatePasswordRequest.getOldPassword(), user.getPassword())) {
      String newHash = passwordEncoder.encode(updatePasswordRequest.getNewPassword());

      kcUserRepository.updatePassword(updatePasswordRequest.getUsername(), newHash);
    } else {
      throw new IllegalArgumentException("Password is incorrect.");
    }
  }

  @Transactional
  public void resetPassword(String username) {
    char[] possibleCharacters = ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
      + "!@#$()-_=+[{]}<>?").toCharArray();

    String newPassword = RandomStringUtils.random(
      16,
      0,
      possibleCharacters.length - 1,
      false,
      false,
      possibleCharacters,
      new SecureRandom()
    );
    System.out.println(newPassword);
    String hash = passwordEncoder.encode(newPassword);

    kcUserRepository.updatePassword(username, hash);
    emailService.sendPasswordReset(username, newPassword);
  }

  @Transactional
  public void deleteUser(String username) {
    kcUserRepository.deleteUser(username);
  }

  public FetchUserResponse mapFetch(KcUser user, List<String> roles) {
    return new FetchUserResponse(
      user.getUid(),
      user.getUsername(),
      user.getExternalReference(),
      user.getIsDisabled(),
      user.getUpdatedAt(),
      user.getCreatedAt(),
      roles
    );
  }

  private KcUser mapCreate(CreateUserRequest request) {
    return new KcUser(
      UUID.randomUUID(),
      request.getExternalReference(),
      request.getUsername(),
      passwordEncoder.encode(request.getPassword()),
      false,
      OffsetDateTime.now(),
      OffsetDateTime.now()
    );
  }
}

package com.hexploits.kc.service.webhook;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.json.JsonMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.hexploits.kc.dto.response.WebhookResponse;
import com.hexploits.kc.service.KcWebhookService;
import io.micronaut.context.annotation.Replaces;
import io.micronaut.context.annotation.Requires;
import jakarta.inject.Singleton;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.UUID;
import com.hexploits.kc.dto.internal.DiscordWebhookBody;
import com.hexploits.kc.dto.internal.EventType;
import com.hexploits.kc.dto.internal.SlackWebhookBody;
import com.hexploits.kc.dto.internal.WebhookBody;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Singleton
@Replaces(IWebhookDispatchService.class)
@Requires(property = "kc.env", value = "prod")
public class ProductionKcWebhookDispatchService implements IWebhookDispatchService {

  private final Logger log = LoggerFactory.getLogger(ProductionKcWebhookDispatchService.class);
  private final KcWebhookService kcWebhookService;

  public ProductionKcWebhookDispatchService(KcWebhookService kcWebhookService) {
    this.kcWebhookService = kcWebhookService;
  }

  public void emit(UUID userUid, String username, String externalReference, EventType eventType) {
    List<WebhookResponse> webhooks = kcWebhookService.fetchWebhooks(eventType);
    webhooks.forEach(webhook -> {
      if (webhook.isDisabled()) {
        return;
      }

      String message =
        "UserUid: " + userUid +
          "\nUsername: " + username +
          "\nEvent Type: " + eventType +
          "\nDescription: " + eventType.getMessage() +
          "\n----------";

      Object body = null;
      if (webhook.getWebhookUrl().startsWith("https://discord.com/")) {
        String avatarUrl = "https://i.pinimg.com/originals/a5/74/55/a574557d0afc633db35f8a7628af0afb.jpg";
        body = new DiscordWebhookBody("KC", message, avatarUrl);

      } else if (webhook.getWebhookUrl().startsWith("https://hooks.slack.com")) {
        body = new SlackWebhookBody(message);

      } else {
        body = new WebhookBody(
          userUid,
          externalReference,
          eventType,
          eventType.getMessage(),
          OffsetDateTime.now()
        );
      }

      log.info("Dispatching webhook to: {}", webhook.getWebhookUrl());

      ObjectMapper objectMapper = JsonMapper.builder()
        .addModule(new JavaTimeModule())
        .build();

      String requestBody = null;
      try {
        requestBody = objectMapper.writeValueAsString(body);
      } catch (JsonProcessingException e) {
        log.error("Failed to parse object to string: {}", e.getLocalizedMessage());
        throw new IllegalStateException("Failed to parse object to string: " + e.getLocalizedMessage());
      }

      HttpClient client = HttpClient.newHttpClient();
      HttpRequest request = HttpRequest.newBuilder()
        .uri(URI.create(webhook.getWebhookUrl()))
        .timeout(Duration.ofSeconds(15))
        .header("Content-Type", "application/json")
        .POST(HttpRequest.BodyPublishers.ofString(requestBody))
        .build();

      try {
        client.sendAsync(request, HttpResponse.BodyHandlers.ofString())
          .thenAccept(HttpResponse::body);
      } catch (Exception e) {
        log.error("Error occurred while sending request to webhook url: {}", webhook.getWebhookUrl());
        throw new IllegalStateException("Error occurred while sending request to webhook: " + e.getLocalizedMessage());
      }

      kcWebhookService.updateLastDispatch(webhook.getUid());
    });
  }
}
